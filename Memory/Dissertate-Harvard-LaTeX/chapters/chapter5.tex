%!TEX root = ../dissertation.tex
\chapter{Implementación y pruebas}
\label{conclusion}

En este capítulo se explican la implementaciones llevadas a cabo en este trabajo y las pruebas que se han realizado sobre las mismas. Los algoritmos por se describen por orden en el pipeline. 
\section{Tokenizador}
El proceso de tokenización implementado recibe como entrada una cadena de texto y da como salida los tokens de la cadena. Si la cadena se compone de varias frases, entonces da como salida el texto segmentado en frases tokenizado. Por ejemplo, si recibe como entrada: \newline
\begin{center}\texttt{"El cielo es azul. El agua es transparente y las amapolas son rojas."}
\end{center}
Dará como salida:
 \texttt{["El", "cielo", "es", "azul", "."]} \newline
\texttt{["El", "agua", "es", "transparente", "y", "las", "amapolas", "son", "rojas", "."]}\newline
El algoritmo de tokenizado se puede dividir en 4 fases:
\begin{enumerate}
\item Preprocesado el string: manejo de comillas (simples y dobles), espacios en blanco, retornos de carro, saltos de línea.
\item Obtención de los tokens del texto
\item Separación de frases
\item Manejo de sarcasmo y emoticonos
\end{enumerate}

Tanto el algoritmo como las estructuras usadas por éste se implementan en una clase \textcolor{SchoolColor}{Tokenizer}. Igual se ha hecho con el resto de clases, pretendiendo así aislar todo la funcionalidad relativa a una clase en la implementación de la misma. Veamos el algoritmo en detalle:
\subsection{Preprocesado del texto recibido}
\begin{minted}
[frame=lines,
framesep=1mm,
fontsize=\footnotesize,
breaklines=true
]{scala}
def find_tokens(string:String):List[List[String]]={
    var s=string
    val punc=punctuation.replace(".","").toCharArray

  //handle unicode quotes
    if(s.contains("“")) s.replace("“"," “ ")
    if(s.contains("”")) s.replace("”"," ” ")
    if(s.contains("‘")) s.replace("‘"," ‘ ")
    if(s.contains("’")) s.replace("’"," ’ ")
   //collapse whitespace
    s="""\r\n""".r.replaceAllIn(s,"\n")
    s="""\n{2,}""".r.replaceAllIn(s,EOS)
    s="""\s+""".r.replaceAllIn(s," ")
\end{minted}
Donde \textsf{punctuation} es una cadena con signos de puntuación, que se define dentro de la clase como: 
\begin{minted}
[frame=lines,
framesep=1.2mm,
fontsize=\footnotesize,
breaklines=true
]{scala}
  private[this] val punctuation = ".,;:!?()[]{}`'\"@#\$^&*+-|=~_"
\end{minted}
En la segunda línea de la función se elimina el punto de entre los signos de puntuación, dado que el punto lo manejaremos aparte, para evitar confusiones como creer que \textsf{"..."} es un final de frase al leer su primer punto. Con eso se construye un array de caracteres \textsf{punc}. \newline
El siguiente paso es espaciar las comillas del texto, ya que el tokenizador busca tokens entre espacios en blanco. Por ejemplo, la frase:  \texttt{Como dice la canción,"vive y sé feliz".} Quedaría:  
\texttt{Como dice la canción, " vive y sé feliz " .} \newline
Finalmente se hace uso de expresiones regulares para sustituir la presencia de \textsf{\escape{r}\escape{n}}, que es el separador de línea que suele usar Windows por un salto de línea, así como cambiar uno o más caracteres en blanco por uno solo y dos o más saltos de línea por \textsf{EOS}, definida anteriormente dentro de la clase como:
\begin{minted}
[frame=lines,
framesep=1.3mm,
fontsize=\footnotesize,
breaklines=true
]{scala}
  private[this] val EOS = "END-OF-SENTENCE"
\end{minted}

\subsection{Obtención de los tokens}
Para obtener los tokens se define el token con una expresión regular de la siguiente forma:
\begin{minted}
[frame=lines,
framesep=1.3mm,
fontsize=\footnotesize,
breaklines=true
]{scala}
private[this] var TOKEN="""(\S+)\s""".r
\end{minted}
Es decir, uno o más caracteres que no sean espacios en blanco seguidos de un espacio en blanco. Ésta expresión regular se usa para encontrar todas las coincididencias de palabras seguidas de un espacio en blanco en el texto (s). Luego, se itera sobre cada una de las coincidencias encontradas de la siguiente manera: \newline
Se comienza eliminando el espacio en blanco final de la palabra: por ejemplo \textsf{"gatos "} $\Rightarrow$ \textsf{"gatos"}, y se comprueba si la primera letra de la palabra es un signo de puntuación distinto del punto. Si lo es, se quita la primera letra de la palabra y se mete en la lista de tokens, repitiendo el mecanismo hasta que la primera letra de la palabra no sea un signo de puntuación. 

\end{itemize} 
\begin{minted}
[frame=lines,
framesep=1.3mm,
fontsize=\footnotesize,
breaklines=true
]{scala}
 //find words
    var tokens=List[String]()
  TOKEN.findAllIn(s+" ").foreach(t => if(t.length>0){
                        var tail=mutable.MutableList[String]()
                        var t2=t.stripSuffix(" ")
                        while (punc.contains(t2.head)){
                          tokens::=t2.head.toString
                          t2=t2.tail
                        }
                        while (punc.contains(t2.last) || t2.endsWith(".")) {
                          if (t2.endsWith("...")) {
                            tail+=("...")
                            t2 = t2.substring(0, t2.length - 3)
                          }
                          else if (punc.contains(t2.last)) {
                            tail+=(t2.substring(t2.length - 1))
                            t2 = t2.substring(0,t2.length-1)
                          } //split elipsis (...) before splitting period

                          //split period(if not an abbreviation)
                          if (t2.endsWith(".")) {
                            if ((abbreviations.contains(t2) || re_abbr1.findAllMatchIn(t2).length > 0 || re_abbr2.findAllMatchIn(t2).length > 0 ||
                              re_abbr3.findAllMatchIn(t2).length > 0)!=true) {

                              tail+=(t2.substring(t2.length-1))
                              t2 = t2.substring(0,t2.length-1)
                            }
                          }
                        }
                        if( t2.compareTo("")!=0){
                          tokens::=t2
                        }
                        if(!tail.isEmpty) {
                          tail.foreach(u=> tokens::=u.toString )
                        }
    })
\end{minted}
 